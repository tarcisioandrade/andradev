---
title: Making Sense of React Server Components
publishedAt: 2023-07-01
description: "This year, the React team unveiled something they've been quietly researching for years: an official way to run React components exclusively on the server. This is a significant paradigm shift, and it's caused a whole lot of confusion in the React community. In this tutorial, we'll explore this new world, and build an intuition for how it works, and how we can take advantage of it."
categories:
  - nextjs
  - typescript
  - perfomance
  - nodejs
  - react native
  - test
isPublished: true
---

So, here's something that makes me feel old: React celebrated its 10th birthday this
year!

In the decade since React was first introduced to a bewildered dev community, it’s gone through several evolutions. The React team has not been shy when it comes to radical changes: if they discover a better solution to a problem, they'll run with it.

A couple of months ago, the React team unveiled React Server Components, the latest paradigm shift. For the first time ever, React components can run exclusively on the server.

There's been so much friggin’ confusion about this online. Lots of folks have lots of questions around what this is, how it works, what the benefits are, and how it fits together with things like Server Side Rendering.

I've been doing a lot of experimentation with React Server Components, and I've answered a lot of my own questions. I have to admit, I'm way more excited about this stuff than I expected to be. It's really cool!

So, my goal today is to help demystify this stuff for you, to answer a lot of the questions you might have about React Server Components!

<Warning>
  **Intended audience**

This tutorial is written primarily for developers who are
already using React, and who are curious about React Server Components. You
don't need to be a React expert, but it will likely be pretty confusing if
you're just getting started with React.

</Warning>

# A quick primer on Server Side Rendering

To put React Server Components in context, it's helpful to understand how Server Side Rendering (SSR) works. If you're already familiar with SSR, feel free to skip to the next heading!

When I first started using React in 2015, most React setups used a “client-side” rendering strategy. The user would receive an HTML file that looked like this:

```html
<!DOCTYPE html>
<html>
  <body>
    <div id="root"></div>
    <script src="/static/js/bundle.js"></script>
  </body>
</html>
```

That <mark>bundle.js</mark> script includes everything we need to mount and run the application, including React, other third-party dependencies, and all of the code we've written.

Once the JS has been downloaded and parsed, React springs into action, conjuring all of the DOM nodes for our entire application, and housing it in that empty <mark>\<div id="root"></mark>.

The problem with this approach is that it takes time to do all of that work. And while it's all happening, the user is staring at a blank white screen. This problem tends to get worse over time: every new feature we ship adds more kilobytes to our JavaScript bundle, prolonging the amount of time that the user has to sit and wait.

The problem with this approach is that it takes time to do all of that work. And while it's all [happening](http://localhost:3000/post-01), the user is staring at a blank white screen. This problem tends to get worse over time: every new feature we ship adds more kilobytes to our JavaScript bundle, prolonging the amount of time that the user has to sit and wait.\*

Server Side Rendering was designed to improve this experience. Instead of sending an empty HTML file, the server will render our application to generate the actual HTML. The user receives a fully-formed HTML document.

That HTML file will still include the <mark>\<script></mark> tag, since we still need React to run on the client, to handle any interactivity. But we configure React to work a little bit differently in-browser: instead of conjuring all of the DOM nodes from scratch, it instead adopts the existing HTML. This process is known as hydration.

I like the way React core team member Dan Abramov explains this:

> Hydration is like watering the “dry” HTML with the “water” of interactivity and event handlers.

Each of these flags represents a commonly-used web performance metric. Here's the breakdown:

1. **First Paint** — The user is no longer staring at a blank white screen. The general layout has been rendered, but the content is still missing. This is sometimes called FCP (First Contentful Paint).
2. **Page Interactive** — React has been downloaded, and our application has been rendered/hydrated. Interactive elements are now fully responsive. This is sometimes called TTI (Time To Interactive).
3. **Content Paint** — The page now includes the stuff the user cares about. We've pulled the data from the database and rendered it in the UI. This is sometimes called LCP [(Largest Contentful Paint)](https://www.markdownguide.org/basic-syntax/#links).

```ts
let hello = "hello brightness";
console.log(hello, "my old friend");
```

![Image](https://res.cloudinary.com/drdzrfm15/image/upload/w_1000/q_auto/f_auto/v1694920648/andradev/server-components/wallhaven-m9j1pk_t0o7wm.jpg)

# Bouncing back and forth

Let's talk about data-fetching in React. Typically, we've had two separate applications that communicate over the network:

A client-side React app
A server-side REST API
Using something like React Query or SWR or Apollo, the client would make a network request to the back-end, which would then grab the data from the database and send it back over the network.

We can visualize this flow using a graph:

## React Server Components MINI

Let's talk about data-fetching in React. Typically, we've had two separate applications that communicate over the network:

A client-side React app
A server-side REST API
Using something like React Query or SWR or Apollo, the client would make a network request to the back-end, which would then

It's beyond the scope of this tutorial, but you can learn more about this architecture on Github.

It's also something we explore in depth in my brand-new course, The Joy of React. I'd love to tell you a little bit more about it, if that's alright! ❤️

The Joy of React is a beginner-friendly interactive course, designed to help you build an intuition for how React works. We start at the very beginning (no prior React experience required), and work our way through some of the most notoriously-tricky aspects of React.

This course has been my full-time focus for almost two years now, and it includes all of the most important stuff I've learned about React in over 8 years of experience.

There's so much good stuff I'd love to tell you about. In addition to React itself, and all the bleeding-edge stuff we've alluded to in this blog post, you'll learn about my favourite parts of the React ecosystem. For example, you'll learn how to do next-level layout animations like this, using Framer Motion:

It's beyond the scope of this tutorial, but you can learn more about this architecture on Github.

It's also something we explore in depth in my brand-new course, The Joy of React. I'd love to tell you a little bit more about it, if that's alright! ❤️

The Joy of React is a beginner-friendly interactive course, designed to help you build an intuition for how React works. We start at the very beginning (no prior React experience required), and work our way through some of the most notoriously-tricky aspects of React.

This course has been my full-time focus for almost two years now, and it includes all of the most important stuff I've learned about React in over 8 years of experience.

There's so much good stuff I'd love to tell you about. In addition to React itself, and all the bleeding-edge stuff we've alluded to in this blog post, you'll learn about my favourite parts of the React ecosystem. For example, you'll learn how to do next-level layout animations like this, using Framer ==Motion==:

https://res.cloudinary.com/drdzrfm15/video/upload/v1695135961/andradev/server-components/ubereats-loading_rw4xdz.mp4

<iframe
  src="https://codesandbox.io/embed/sandpack-project-yw1065?fontsize=14&hidenavigation=1&theme=dark"
  title="sandpack-project"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>
